// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

import static edu.wpi.first.units.Units.*;

import com.ctre.phoenix6.swerve.SwerveModule.DriveRequestType;
import com.ctre.phoenix6.swerve.SwerveRequest;

import edu.wpi.first.math.MathUtil;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.wpilibj.RobotBase;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.Commands;
import edu.wpi.first.wpilibj2.command.button.CommandXboxController;
import edu.wpi.first.wpilibj2.command.button.RobotModeTriggers;
import edu.wpi.first.wpilibj2.command.sysid.SysIdRoutine.Direction;

import frc.robot.generated.TunerConstants;
import frc.robot.subsystems.CommandSwerveDrivetrain;
import frc.robot.subsystems.auto.AutoLogic;

/**
 * The RobotContainer class is where the bulk of the robot structure is declared. 
 * 
 * <p>This class centralizes the hardware instances, UI device bindings, and 
 * the mapping between operator inputs and subsystem commands for the 2026 season.
 */
public class RobotContainer {

    /** Maximum linear velocity of the robot in meters per second. */
    private double MaxSpeed = TunerConstants.kSpeedAt12Volts.in(MetersPerSecond);
    /** Maximum angular velocity of the robot in radians per second. */
    private double MaxAngularRate = RotationsPerSecond.of(0.75).in(RadiansPerSecond);

    /** Standard field-centric swerve request. Uses Velocity control for smoother movement. */
    private final SwerveRequest.FieldCentric drive = new SwerveRequest.FieldCentric()
            .withDeadband(0.0001)
            .withRotationalDeadband(0.0001)
            .withDriveRequestType(DriveRequestType.Velocity);

    /** Brake request: Forces all modules into an X-pattern to resist movement. */
    private final SwerveRequest.SwerveDriveBrake brake = new SwerveRequest.SwerveDriveBrake();
    /** Point request: Orients all modules toward a specific direction without driving. */
    private final SwerveRequest.PointWheelsAt point = new SwerveRequest.PointWheelsAt();

    /** Telemetry helper for logging drivetrain state to AdvantageScope/Dashboard. */
    private final Telemetry logger = new Telemetry(MaxSpeed);
    /** Primary driver controller (Port 0). */
    private final CommandXboxController joystick = new CommandXboxController(0);

    /** The drivetrain subsystem, initialized using constants generated by Tuner X. */
    public final CommandSwerveDrivetrain drivetrain = TunerConstants.createDrivetrain();

    /**
     * Constructs the RobotContainer.
     * Initializes autonomous selection dashboards and binds controller inputs to commands.
     */
    public RobotContainer() {      
        AutoLogic.initShuffleboard(drivetrain); 
        configureBindings();
    }

    /**
     * Processes raw joystick input for translation (X-axis).
     * 
     * @return Scaled velocity in meters per second.
     */
    private double getDriveX() {
        // Apply 10% deadband to ignore stick drift; invert for standard field coordinate system
        double input = MathUtil.applyDeadband(-joystick.getLeftY(), 0.1);
        // Reduce speed by 50% if the Right Bumper is held for fine positioning
        double inputScale = joystick.rightBumper().getAsBoolean() ? 0.5 : 1.0;
        return input * MaxSpeed * inputScale;
    }

    /**
     * Processes raw joystick input for translation (Y-axis).
     * 
     * @return Scaled velocity in meters per second.
     */
    private double getDriveY() {
        // Joystick +X is right, Robot +Y is left (standard FieldCentric convention)
        double input = MathUtil.applyDeadband(-joystick.getLeftX(), 0.1);
        double inputScale = joystick.rightBumper().getAsBoolean() ? 0.5 : 1.0;
        return input * MaxSpeed * inputScale;
    }

    /**
     * Processes raw joystick input for rotation.
     * 
     * @return Scaled angular velocity in radians per second.
     */
    private double getDriveRotate() {
        // Joystick +X is right, Robot +angle is CCW (left)
        double input = MathUtil.applyDeadband(-joystick.getRightX(), 0.1);
        double inputScale = joystick.rightBumper().getAsBoolean() ? 0.5 : 1.0;
        return input * MaxAngularRate * inputScale;
    }

    /**
     * Defines trigger-to-command mappings.
     */
    private void configureBindings() {
        // Set the default command for the drivetrain to follow joystick inputs continuously
        drivetrain.setDefaultCommand(
            drivetrain.applyRequest(() ->
                drive.withVelocityX(getDriveX())
                     .withVelocityY(getDriveY())
                     .withRotationalRate(getDriveRotate())
            )
        );

        // Keep the drivetrain in an Idle state while the robot is disabled
        final var idle = new SwerveRequest.Idle();
        RobotModeTriggers.disabled().whileTrue(
            drivetrain.applyRequest(() -> idle).ignoringDisable(true)
        );

        // Map Button A to the brake command for defensive positioning
        joystick.a().whileTrue(drivetrain.applyRequest(() -> brake));
        
        // Map Button B to orient wheels based on the left joystick angle (useful for testing)
        joystick.b().whileTrue(drivetrain.applyRequest(() ->
            point.withModuleDirection(new Rotation2d(-joystick.getLeftY(), -joystick.getLeftX()))
        ));

        // SysId Characterization bindings (Back/Start + X/Y) for automated PID tuning
        joystick.back().and(joystick.y()).whileTrue(drivetrain.sysIdDynamic(Direction.kForward));
        joystick.back().and(joystick.x()).whileTrue(drivetrain.sysIdDynamic(Direction.kReverse));
        joystick.start().and(joystick.y()).whileTrue(drivetrain.sysIdQuasistatic(Direction.kForward));
        joystick.start().and(joystick.x()).whileTrue(drivetrain.sysIdQuasistatic(Direction.kReverse));

        // Recalibrate the gyro's forward heading using the Left Bumper
        joystick.leftBumper().onTrue(drivetrain.runOnce(() -> drivetrain.seedFieldCentric()));

        // Hook up the telemetry logger to the drivetrain periodic updates
        drivetrain.registerTelemetry(logger::telemeterize);
    }

    /**
     * Wrapper for team-specific commands to handle simulation behavior.
     * 
     * @param command The command to wrap.
     * @return The original command or an empty command if in simulation.
     */
    private Command CmdWrapperTeamCommand(Command command) {
        if (RobotBase.isSimulation()) {
            return Commands.none(); 
        }
        return command;
    }
    
    /**
     * Retrieves the autonomous routine selected via the dashboard at the start of the match.
     * 
     * @return The command to execute during the autonomous period.
     */
    public Command getAutonomousCommand() {
        return AutoLogic.getSelectedAutoCommand();
    }
}
