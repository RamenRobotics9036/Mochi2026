/*
  Guidance for AI coding agents working on the Mochi2026 (Ramen Robotics) codebase.
  Keep this short and actionable (20-50 lines). Update when project layout or build changes.
*/

# Mochi2026 — Copilot instructions

This Java WPILib robot project (team FRC) uses GradleRIO and CTRE Phoenix 6 Swerve code generated
by the Tuner X Swerve Project Generator. Focus on making safe, minimal, and testable changes.

Key entry points
- `src/main/java/frc/robot/Main.java` — program entry; calls `Robot`.
- `src/main/java/frc/robot/Robot.java` — WPILib `TimedRobot`; registers `RobotContainer`.
- `src/main/java/frc/robot/RobotContainer.java` — binds controls, default commands, and creates drivetrain.
- `src/main/java/frc/robot/generated/TunerConstants.java` — auto-generated CTRE hardware & tuning constants; treat as authoritative for IDs, gear ratios, and CAN bus settings.

Primary subsystems and responsibilities
- `CommandSwerveDrivetrain` (in `subsystems`) wraps the CTRE swerve drivetrain and implements command-based behaviors, SysId routines, and simulation hooks. Prefer using `applyRequest(...)` and existing SysId helpers.
- `Telemetry` publishes NetworkTables and SignalLogger entries — keep message formats unchanged when updating telemetry names.
- `AutoLogic` (in `subsystems/auto`) loads PathPlanner autos and exposes a Shuffleboard chooser; autos are stored under `src/main/deploy/pathplanner`.

Build, run, and test
- Standard GradleRIO flows via Gradle wrapper (Windows PowerShell):
  - Build: `./gradlew build` (on Windows, run `.\\gradlew.bat build`)
  - Run tests: `.
    gradlew test` or `.
    gradlew.bat test` — project uses JUnit5.
  - Deploy to RoboRIO: `.
    gradlew deploy` (requires team settings/robot connected)
- Simulation: GradleRIO includes desktop simulation support; `wpi.sim.addGui()` is enabled in `build.gradle`. Use the Gradle tasks provided by GradleRIO for simulation (e.g., `./gradlew simulate` if available). Verify available tasks with `./gradlew tasks`.

Project conventions and patterns
- Generated constants: `TunerConstants.java` is generated by a CTRE tool. Avoid editing its hardware IDs, offsets, or CAN bus strings unless updating generator inputs; prefer regenerating instead.
- Commands: use WPILib command-based style; `setDefaultCommand(...)` and `applyRequest(...)` are common.
- Telemetry: NetworkTables topics are explicit (see `Telemetry`). If adding fields, use similar `.publish()` calls and keep the existing topic names (e.g., `DriveState/*`, `Pose/robotPose`).
- Simulation: Classes detect `Utils.isSimulation()` and start sim threads — keep simulation hooks when refactoring.

Integration points and external deps
- CTRE Phoenix 6 (com.ctre.phoenix6.*) — hardware API and simulation. Look at `TunerConstants` and `CommandSwerveDrivetrain` for usage.
- PathPlanner (`com.pathplanner.lib.*`) for trajectory autos; auto files live in `src/main/deploy/pathplanner`.
- NetworkTables & SignalLogger for telemetry and recording; do not change topic names without updating consumers.

Quick examples to follow
- Add a new networktable value: mirror `Telemetry.driveTimestamp` pattern (get table, create DoublePublisher, call `.publish()` and then `set()` in telemeterize).
- Add a button binding: follow `RobotContainer.configureBindings()` and use `joystick.leftBumper().onTrue(...)` pattern.
- Create a drivetrain request: use `drivetrain.applyRequest(() -> new SwerveRequest.FieldCentric().withVelocityX(x).withVelocityY(y))`.

Testing and safety
- Avoid changing motor IDs, encoder offsets, or CANBus names without hardware confirmation; these are critical for real robot safety.
- For any change affecting runtime (motors, controllers), ensure it compiles and run simulation locally before deploy.

Files to inspect for context when making changes
- `build.gradle`, `settings.gradle` — GradleRIO configuration and simulation flags
- `src/main/java/frc/robot/generated/TunerConstants.java` — hardware mapping
- `src/main/java/frc/robot/subsystems/CommandSwerveDrivetrain.java` — drivetrain control and SysId
- `src/main/java/frc/robot/subsystems/auto/AutoLogic.java` — auto selection and PathPlanner usage

If anything here is unclear or you need deeper detail (e.g., where CAN log files are stored, or how autos get packaged), ask and I will expand the file with exact commands and code examples.
